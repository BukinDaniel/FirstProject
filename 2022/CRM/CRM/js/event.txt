Способы работы с событиями
1. Использования атрибута HTML ( в любой html объект мы можем добавить атрибут, например onclick и присвоить ему какой-то JS код(например вывод чего-либо в консоль)
<button onclick="console.log('Hi!') type="button" и т.д.>
При клике на этот объект мы получим результат нашего кода. Но лучше всё же использовать JS в отдельном JS файле, работая с DOM.

2.Использование DOM объекта
Обращаемся к объекту через querySelector и помещаем это всё в const имяконст. (например button)
Далее:
button.onclick = function(){ // onclick здесь и есть обработчик события
	console.log('Hi!');}

Есть другой метод записи такого функционала:
function showConsole(){
	console.log('Hi!');}
button.onclick = showConsole; // важно, что без скобок, ибо если будут скобки - функция выполнится автоматически, а не по клику.

Недостаток такого метода - невозможность повесить несколько обработчиков на событие. Кажое новое назначение обработчика перезапишет предудыщее.
Для этого существует основной способ назначения обработчиков при помощи специальных методов addEventListener и removeEventListener, которые лишены этого недостатка.
Синтаксис имяобъекта.addEventListener (event, handler [, options]); event - событие, handler - функция без имени с кодом, который будет выполняться ( либо просто имя функции)
Пример:
const button = document.querySelector('.button');
button.addEventListener("click", function (e) {
	console.log('Hi!);});
button.addEventListener("click", function (e) {
	console.log('Peter!);});

Если же делать через отдельную функцию: 1. Описываем функцию и код. 2. Используем addEventListener. (не забыть перед этим обратится к объекту)
ремув используется для отключения обработчика.(например если нужно нажать на кнопку один раз,чтобы она выполнила одно действие, а затем отключить этот функционал)
const button = document.querySelector('.button');
function showConsole(){
	console.log('Hi!');
button.remoteEventListener("click" , showConsole);
}
button.addEventListener("click" , showConsole); //вызов функции внутри который используется функционал remove.

у данных способов назначения есть опции : 
"capture ": true / false; // фаза на которой должен сработать обработчик
"once": false / true; // если тру тогда обработчик будет автоматически удалён после выполнения(как будто сразу добавлен remove)
"passive": true / false; // если тру то указывает что обработчик никогда не вызовет preventDefault()
Эти опции можно описать отдельно в const options и добавить в момент вызова обработчика после имя функции, либо можно прописать прям в обработчике также после вызова
имени функции, но в фигурных скобках

3. Объект события
Нужно для того, чтобы передать детали того, что произошло(не просто клик или нажатие, а добавление координат мыши, какая именно клавиша нажата и тд)
const button = document.querySelector('.button');

function showConsole(event) { // event - принятно так называть событие
console.log(event.type); // type передает какое именно событие произошло при обработчике(в данным момент - click).
console.log(event.target); // объект на котором произошло событие
console.log(event.currentTarget); // объект к которому назначен обработчик
console.log(event.clientX); // положение курсора по оси X
console.log(event.clientY); // положение курсора по оси Y
console.log(event); // все детали события
}
button.addEventListener("click" , showConsole);

Понятия "Всплытие и погружение"
Всплытие - когда на элементе происходит событие , обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.
Если мы хотим остановить всплытие, то в обработчик события необходимо добавить
event.stopPropagation();
Останавливать всплытие стоит очень осторожно, точно понимая для чего мы это делаем.
Погружение - когда вызывается обработчки события(допускаем вложенность элементов html, для представления работы) одного вложенного элемента в другой, мы можем
отловить откуда именно началось "погружение" в обработчики. При нажатии на элемент(на обработчике которого установлен caprure true о котором говорилось ранее) мы 
начинаем погружение именно с того элемента, на котором произошло событие до последнего элемента, а затем начинается всплытие наверх. ДА, СЛОЖНО, но понять надо.
В целом, используется редко

Делегирование событий.
Если мы хотим чтобы при нажатии на различные кнопки выполнялся один и тот же код, мы как раз используем делегирование:
const button = document.querySelectorAll('.button'); // Внимание! Получаем не одну кнопку, а коллекцию querySelectorAll
function showConsole(){
	console.log('WOW!'):
}
button.forEach(buttonItem => {
	button.Item.addEventListener("click", showConsole);});
Проблема такого кода - большая нагрузка на браузер, ибо у нас имеется множество кнопок с событиями.
Чтобы избежать этого, как раз используется делегирование - смотрим к какому классу принадлежит наш объект и работаем с ним( с родителем)
const имяродителя(lesson в нашем случае) = document.querySelector('.lesson');
function showConsole(){
	console.log('WOW!');}
lesson.addEventListener("click", function (event) {
	if (event.target.closest('.button')) { // closest здесь для проверки на то, кликнули мы на сам объект button или на его дочерний элемент (например span внутри button)
		showConsole();}
});
В данном примере как раз всего один обработчик, а не как выше,где количество обработчиков равно количеству button на странице.

Действия браузера по умолчанию и их отмена.